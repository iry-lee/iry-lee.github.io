##### [Leetcode-1239. 串联字符串的最大长度 ](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/submissions/)

难度：⭐⭐

自己完成程度：自己独立完成，使用位运算加速，运行时间也大大加快

<img src="字符串.assets/image-20201206160849687.png" alt="image-20201206160849687" style="zoom:50%;" />

思路：这个题既是一个字符串的题，又可以看作是一个动态规划的题，还可以看作是一个位运算的题，在我的解法中用到了一些位运算的思想。然后看了一下解答，这居然还是一个回溯算法的题。

```c++
// 本题的最优解的最大值就是26，也就是说，DP数组其中一个维度的最大值就是26
// 字符串中最多也只出现26个字母，于是可以用32位的int来存储
class Solution {
private:
    const int Size = 26;
public:
    int countOne(int a){
        int ct = 0;
        while(a != 0){
            a = a & (a-1);
            ct++;
        }
        return ct;
    }

    int maxLength(vector<string>& arr) {
        int size = arr.size();
        vector<int> newarr;
        // 将字符串存储转换为int其实只用到26位
        for(int i = 0; i < size; i++){
            int val = 0;
            for(char c : arr[i]){
                int bit = 1 << (c - 'a');
                // (val & bit) == 0 说明这个字母在这个单词中目前没有出现过
                if((val & bit) == 0){
                    val += bit;
                }
                // 如果这个字母在这个单词中已经出现过，这个就没用了
                else{
                    val = 0;
                    break;
                }
            }
            if(val != 0) newarr.push_back(val);
        }
        
        // 建立dp数组
        vector<vector<int>> dp (Size);
        for(int i = 0; i < newarr.size(); i++){
            int ct = countOne(newarr[i]);
            // 先看看可不可以将自己加在别的字符串后面
            for(int j = Size-1; j >= 0; j--){
                for(int k = 0; k < dp[j].size(); k++){
                    if((newarr[i] & dp[j][k]) == 0){
                        dp[j+ct].push_back(newarr[i]+dp[j][k]);
                    }
                }
            }
            // 再把自己插进去
            dp[ct-1].push_back(newarr[i]);
        }
        
        for(int i = Size-1; i >= 0; i--){
            if(dp[i].size() >= 1) return i+1;
        }
        return 0;
    }
};
```



### 回文串系列

##### [Leetcode-5. 最长回文子串（Manacher算法）](https://leetcode-cn.com/problems/longest-palindromic-substring)

这里介绍一下马拉车（Manacher）算法。左神在《程序员代码面试指南》里讲的很清楚，就不在这里具体展开了。主要大致介绍一下思路：



```c++
class Solution {
private:
    // 给字符串中插入#
    string manacherStr(string &str){
	    string new_str = "";
	    for(char c : str){
		    new_str.append(1, '#');
		    new_str.append(1, c);
	    }
	    new_str.append(1, '#');
	    return new_str;
    }
    // 计算从ptr开始，有多少对以index为中心的字符，遇到第一个不一样的便停止
    int palindromeCount(string &str, int center, int &ptr){
        int count = 0;
        int _ptr = (center << 1) - ptr;
        while(_ptr >= 0 && ptr < str.size() && str[_ptr] == str[ptr]){
            count++;
            _ptr--;
            ptr++;
        }
        return count;
    }
    // manacher算法
    vector<int> manacher(string &s){
        s = manacherStr(s);
        vector<int> vec (s.size(), 0);
        int ptr = 0, index = 0;
        for(int i = 0; i < s.size(); i++){
            if(ptr <= i){
                vec[i] = palindromeCount(s, i, ptr);
                index = i;
            }
            else{
                int _i = (index << 1) - i; 
                int _radius = vec[_i];
                if(i + _radius - 1 < ptr-1){
                    vec[i] = _radius;
                }
                else if(i + _radius - 1 > ptr-1){
                    vec[i] = ptr - i;
                }
                else{   //i + _radius - 1 == ptr
                    vec[i] = ptr - i;
                    vec[i] += palindromeCount(s, i, ptr);
                    index = i;
                }
            }
        }
        return vec;
    }
public:
    string longestPalindrome(string s) {
        vector<int> vec = manacher(s);
        string ans = "";

        // 寻找最长回文串
        int maxi = 0, max = vec[0];
        for(int i = 0; i < vec.size(); i++){
            if(vec[i] > max){
                max = vec[i];
                maxi = i;
            }
        }

        // 解码输出
        int offset = maxi - max + 1, len = (max << 1) - 1;
        for(int i = 0; i < len; i++){
            if(s[offset+i] != '#'){
                ans.append(1, s[offset+i]);
            }
        }

        return ans;
    }
};
```



##### [Leetcode-647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

